#include "assert.h"
#include "pbase/rhc/string.h"
#include "pbase/rhc/str_parse.h"
#include "pbase/rhc/file.h"
#include "pbase/io/stl.h"
#include "pbase/mathc/vec/vec3.h"
#include "locale.h"

#define TYPE vec4
#define CLASS Vec4Arr
#define FN_NAME vec4arr
#include "pbase/rhc/dynarray.h"

//
// private
//

static vec3 triangle_normal(vec3 a, vec3 b, vec3 c) {
    return vec3_normalize(vec3_cross(vec3_sub_vec(b, a), vec3_sub_vec(c, a)));
}

static void append_vec3(String *s, vec3 v) {
    char buffer[128];
    snprintf(buffer, 128, "%f %f %f", v.x, v.y, v.z);
    string_append(s, strc(buffer));
}

static Str_s eat_vec3_ascii(Str_s s, vec3 *out_v) {
    s = str_eat_float_ascii(s, &out_v->x);
    s = str_eat_float_ascii(s, &out_v->y);
    s = str_eat_float_ascii(s, &out_v->z);
    return s;
}

static Str_s eat_vec3_le(Str_s s, vec3 *out_v) {
    s = str_eat_float_binary_le(s, &out_v->x);
    s = str_eat_float_binary_le(s, &out_v->y);
    s = str_eat_float_binary_le(s, &out_v->z);
    return s;
}

static Str_s feed_vec3_le(Str_s str, vec3 v) {
    str = str_feed_float_binary_le(str, v.x);
    str = str_feed_float_binary_le(str, v.y);
    str = str_feed_float_binary_le(str, v.z);
    return str;
}

static String generate_ascii(pCloud cloud, pMeshIndices indices) {
    if(!p_cloud_valid(cloud) || !p_mesh_indices_valid(indices))
        return string_new_invalid();

    // to print in C style (3.14, instead of 3,14 on some machines)
    setlocale(LC_ALL, "C");

    String data = string_new(512);
    String *s = &data;

    string_append(s, strc("solid pbase_io_stl (Meshed)\n"));
    for(size_t t=0; t<indices.size; t++) {
        string_append(s, strc("  facet normal "));
        vec3 a = cloud.data[indices.data[t].v0].xyz;
        vec3 b = cloud.data[indices.data[t].v1].xyz;
        vec3 c = cloud.data[indices.data[t].v2].xyz;
        append_vec3(s, triangle_normal(a, b, c));
        string_append(s, strc("\n    outer loop"));
        for(int abc=0; abc<3; abc++) {
            string_append(s, strc("\n      vertex "));
            append_vec3(s, (vec3[]) {a, b, c}[abc]);
        }
        string_append(s, strc("\n    endloop\n  endfacet\n"));
    }
    string_append(s, strc("endsolid Mesh\n"));

    return data;
}

static String generate_binary(pCloud cloud, pMeshIndices indices) {
    if(!p_cloud_valid(cloud) || !p_mesh_indices_valid(indices))
        return string_new_invalid();

    size_t header_size = 80 + 4;
    size_t triangle_size = 50;
    size_t file_size = header_size + triangle_size * indices.size;

    String data = string_new(file_size);
    data.size = file_size;

    memset(data.data, 0, 80);
    sprintf(data.data, "%s", "STL binary generated by pbase_io_stl");

    Str_s s = data.str;
    s.data+=80;
    s.size-=80;

    // stl is little endian
    s = str_feed_uint32_binary_le(s, indices.size);

    for(size_t t=0; t<indices.size; t++) {
        vec3 a = cloud.data[indices.data[t].v0].xyz;
        vec3 b = cloud.data[indices.data[t].v1].xyz;
        vec3 c = cloud.data[indices.data[t].v2].xyz;
        s = feed_vec3_le(s, triangle_normal(a, b, c));
        for(int abc=0; abc<3; abc++) {
            s = feed_vec3_le(s, (vec3[]) {a, b, c}[abc]);
        }
        s = str_feed_uint16_binary_le(s, 0);    // Attribute byte count
    }

    if(s.data != data.data + file_size || s.size != 0) {
        log_error("p_io_stl failed to generate binary");
    }

    return data;
}

pError parse_ascii(pCloud *out_points, Str_s data) {
    if(!str_begins_with(data, strc("solid"))) {
        return p_error_set("Not an ascii STL file");
    }

    // to print in C style (3.14, instead of 3,14 on some machines)
    setlocale(LC_ALL, "C");

    Str_s s = data;
    s = str_eat_until(s, '\n', NULL);

    Vec4Arr arr = vec4arr_new(128);

    bool valid = false;
    for(;;) {
        s = str_lstrip(s, ' ');

        if(str_begins_with(s, strc("endsolid"))) {
            valid = true;
            break;
        }

        s = str_eat_str(s, strc("facet normal"));
        vec3 normal;
        s = eat_vec3_ascii(s, &normal);
        s = str_lstrip(s, ' ');
        s = str_eat_str(s, strc("outer loop"));
        vec3 a, b, c;
        for(int abc=0; abc<3; abc++) {
            s = str_lstrip(s, ' ');
            s = str_eat_str(s, strc("vertex"));
            s = eat_vec3_ascii(s, (vec3*[]){&a, &b, &c}[abc]);
        }
        s = str_lstrip(s, ' ');
        s = str_eat_str(s, strc("endloop"));
        s = str_lstrip(s, ' ');
        s = str_eat_str(s, strc("endfacet"));

        if(str_valid(s)) {
            vec3 calced_normal = triangle_normal(a, b, c);
            vec4arr_push(&arr, (vec4) {{a.x, a.y, a.z, 1}});
            if(vec3_dot(normal, calced_normal) > 0) {
                vec4arr_push(&arr, (vec4) {{b.x, b.y, b.z, 1}});
                vec4arr_push(&arr, (vec4) {{c.x, c.y, c.z, 1}});
            } else {
                vec4arr_push(&arr, (vec4) {{c.x, c.y, c.z, 1}});
                vec4arr_push(&arr, (vec4) {{b.x, b.y, b.z, 1}});
            }
        } else {
            break;
        }
    }

    if(valid) {
        // move
        out_points->data = arr.array;
        out_points->size = arr.size;
    } else {
        vec4arr_kill(&arr);
        *out_points = p_cloud_new_invalid();
        p_error_set("Failed to parse stl file");
    }

    return p_error();
}

pError parse_binary(pCloud *out_points, Str_s data) {
    if(str_begins_with(data, strc("solid"))) {
        return p_error_set("Not a binary STL file");
    }

    Str_s s = data;
    s = str_eat(s, 80); // Header

    // stl is little endian
    uint32_t triangles;
    s = str_eat_uint32_binary_le(s, &triangles);

    if(!str_valid(s) || triangles == 0)
        return p_error_set("Failed to parse stl file");

    *out_points = p_cloud_new_empty(triangles*3);

    for(uint32_t t=0; t<triangles; t++) {
        vec3 normal, a, b, c;
        s = eat_vec3_le(s, &normal);
        s = eat_vec3_le(s, &a);
        s = eat_vec3_le(s, &b);
        s = eat_vec3_le(s, &c);
        uint16_t attr_byte_cnt;
        s = str_eat_uint16_binary_le(s, &attr_byte_cnt);  // Attribute byte count

        if(!str_valid(s) || attr_byte_cnt != 0) {
            p_error_set("Failed to parse stl file");
            break;
        }

        vec3 calced_normal = triangle_normal(a, b, c);
        out_points->data[t*3+0] = (vec4) {{a.x, a.y, a.z, 1}};
        if(vec3_dot(normal, calced_normal) > 0) {
            out_points->data[t*3+1] = (vec4) {{b.x, b.y, b.z, 1}};
            out_points->data[t*3+2] = (vec4) {{c.x, c.y, c.z, 1}};
        } else {
            out_points->data[t*3+1] = (vec4) {{c.x, c.y, c.z, 1}};
            out_points->data[t*3+2] = (vec4) {{b.x, b.y, b.z, 1}};
        }
    }
    
    if(p_error()) {
        p_cloud_kill(out_points);
    }

    return p_error();
}


//
// public
//

pError p_io_save_mesh_stl(pCloud points, pMeshIndices indices, const char *file, bool ascii) {
    String data;
    if(ascii)
        data = generate_ascii(points, indices);
    else
        data = generate_binary(points, indices);

    if(!file_write(file, data.str, ascii)) {
        log_error("p_io_save_mesh_stl failed to write file");
        assert(p_error());  // should be set by file_write
    }

    string_kill(&data);
    return p_error();
}

pError p_io_load_mesh_stl(pCloud *out_points, pMeshIndices *out_opt_indices, const char *file) {
    String data = file_read(file, true);

    if(!string_valid(data)) {
        log_warn("p_io_load_mesh_stl failed, could not read file: %s", file);
        assert(p_error());  // should be set by file_read
        return p_error();
    }

    bool ascii;
    if(str_begins_with(data.str, strc("solid"))) {
        ascii = true;
    } else {
        ascii = false;
        string_kill(&data);
        data = file_read(file, false);
    }

    if(ascii)
        parse_ascii(out_points, data.str);
    else
        parse_binary(out_points, data.str);

    string_kill(&data);

    if(out_opt_indices) {
        *out_opt_indices = p_mesh_indices_new_count_up(out_points->size/3);
    }

    return p_error();
}
