import numpy as np
import ctypes as ct
from typing import Tuple, List, Optional

from .. import mathctypes
from .. import bindingbase as bb
from .. import types as t
from .. import error

from .. import plib

# /** Saves an stl mesh */
# pError p_io_save_mesh_stl(pCloud points, pMeshIndices indices, const char *file, bool ascii);
plib.p_io_save_mesh_stl.argtypes = [t.pCloud, t.pMeshIndices, bb.c_char_p, bb.c_bool]
plib.p_io_save_mesh_stl.restype = error.pError


def save_mesh_stl(points: np.ndarray, indices: np.ndarray, file: str, ascii: bool):
    '''
    Saves an stl mesh
    '''
    err = plib.p_io_save_mesh_stl(t.cast_into_pCloud(points), t.cast_into_pMeshIndices(indices),
                                  file.encode(), ascii)
    if err is not None:
        raise RuntimeError(err.decode())


# /** Loads an stl mesh, pMeshIndices can be generated by p_mesh_indices_new_count_up(out_points.size/3) */
# pError p_io_load_mesh_stl(pCloud *out_points, const char *file);
plib.p_io_load_mesh_stl.argtypes = [t.pCloud_p, bb.c_char_p]
plib.p_io_load_mesh_stl.restype = error.pError


def load_mesh_stl(file: str)\
        -> t.NpCloud:
    '''
    Loads an stl mesh, pMeshIndices can be generated by p_mesh_indices_new_count_up(out_points.size/3)

    :returns: out_points
    '''
    out_points = t.pCloud()
    err = plib.p_io_load_mesh_stl(bb.ref(out_points), file.encode())
    if err is not None:
        raise RuntimeError(err.decode())
    return t.cast_from_pCloud(out_points)
